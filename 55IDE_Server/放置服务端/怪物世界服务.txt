171000程序集名备注8|6|4|201|2-3-4
170100怪物线程
121100变量名类型公开备注1|2|3|4
120000键值键值表用于记录怪物死亡时间

231000子程序名返回值类型异步公开备注8|10|4|4|41|2|3|4|5-6
230100刷怪线程
!!数组循环(数组玩家, i)
 // 注：与易语言不同的是 数组从0成员开始
let LastTime = 取时间戳()
 // 
let Json = {}
let 玩家 = 申明自定义(玩家类)
玩家 = 数组玩家[i]
!!如果(玩家.套接字 == 0)
到循环尾()
""如果结束()
 // 副本倒计时，不管玩家进入什么副本都是有倒计时的，奖励必须是清理完当前脚本逻辑里面设定的怪物，这里会检测怪物是否清理完毕
!!如果(LastTime - 玩家.副本到期时间 >= 0 且 玩家.副本 == 真 且 玩家.副本到期时间 != 0)
 // 副本结束
退出战场(玩家)

""如果结束()
 // 如果在副本里面则执行副本逻辑
!!如果(玩家.副本 == 真)
 // /////////////开始挂机数据//////////////////////////////////////////
PVE系统(玩家, LastTime, Json)
 // 怪物打人
EVP系统(玩家, LastTime, Json)
 // 玩家挑战系统
PVP系统(玩家, LastTime, Json)
 // 玩家反击
PVP系统_反制(玩家, LastTime, Json)

""如果结束()

""数组循环结束()

231000子程序名返回值类型异步公开备注8|10|4|4|6|681|2|3|4|5-6
230100退出战场时间到，退出地图，结算奖励，时间到退出战场基本是未完成任务，给一点安慰奖励
241100参数名类型备用可空初始值备注1|2|3|4|5|6
240000玩家玩家类
玩家.开始PVP = 假
 // 退出副本
玩家.副本 = 假
 // 推送退出功能
let A = "1 " + 玩家.上个地图ID + " " + 玩家.上个x + " " + 玩家.上个y + " 0"
 // 
脚本1003传送(玩家.套接字, A)
 // 
玩家.副本到期时间 = 0
 // 清空怪物组 
玩家.怪物数组 = []
 // 
玩家.攻击目标 = 0
 // 战场奖励接口，根据玩家杀了多少怪物来计算。看自己写算法了。我这里就直接默认奖励。
提示核心(玩家.套接字, "副本平分:C- 奖励:随机道具1-5个~", )

 // 发放奖励 让玩家在NPC上领取，根据不同奖励
 // 获取随机装备
let 数量 = 取随机数(1, 5)
!!计次循环首(数量, o)
let item = 物品随机给与()
服务端调试输出("给与:" + 玩家.属性.名称 + " 物品:" + item)
脚本501给予物品(玩家.套接字, item)


""计次循环首结束()
 // 



231000子程序名返回值类型异步公开备注8|10|4|4|6|61|2|3|4|5-6
230100PVP系统
241100参数名类型备用可空初始值备注1|2|3|4|5|6
240000玩家玩家类
240000LastTime数值型
240000Json对象型
351100变量名类型备用备注8|8|4|41|2|3|4
350000对战玩家玩家类
350000当前属性玩家属性
350000对战属性玩家属性
!!如果(玩家.开始PVP == 假)
返回(0)
""如果结束()
!!如果(玩家.PVP对象 == 0)
返回(0)
""如果结束()
 // 开始玩家与玩家之间的PK
!!如果(玩家.PVP挂接 == 0)
玩家.PVP挂接 = 拷贝对象(玩家.PVP对象.属性)
对战属性 = 玩家.PVP挂接
##否则
对战属性 = 玩家.PVP挂接
""如果结束()
 // 最底不能低于400ms每次攻击 也就是一秒2.5次攻击 参考LOL2.5攻速上限
!!如果(LastTime - 玩家.上次攻击时间 < 100 / 玩家.属性.攻速 * 2000 或 LastTime - 玩家.上次攻击时间 < 400)
返回(0)
""如果结束()
 // 
玩家.上次攻击时间 = LastTime
 // 
let hit = 1 // 玩属性.攻击 - 怪属性.物防
!!如果(hit < 1)
hit = 1
""如果结束()
 // 玩家.攻击目标 = 刷怪
对战属性.生命大 = 对战属性.生命大 - hit
 // 发送攻击包
Json = 数据Json初始化()
Json.Hex = 6007
 // 包类型，怪物是受伤还是死亡 1 攻击   0 死亡
!!如果(对战属性.生命大 <= 0)
 // 怪物死亡要设置属性
Json.type = 1
 // 怪物死亡奖励
Json.info = 击杀玩家奖励(玩家, 对战玩家)
 // 怪物死亡通知
Json.str = 对战属性.名称 + ' 被你击败了~'
 // 完结当前攻击回合
玩家.PVP对象 = 0
玩家.PVP挂接 = 0
##否则
Json.type = 0
Json.str = 对战属性.名称 + ' 受伤 生命值 - ' + hit
""如果结束()

Json.index = 5 // 被攻击序号
Json.Tndex = 4 // 发起攻击序号
 // 计算伤害
Json.hit = 对战属性.生命大
 // 攻速 客户端已经取消攻速。
Json.speed = 200
 // 推送
服务端数据发送(玩家.套接字, Json)


231000子程序名返回值类型异步公开备注1|2|3|4|5-6
230100PVP系统_反制Pk的玩家反击
241100参数名类型备用可空初始值备注1|2|3|4|5|6
240000玩家玩家类
240000LastTime数值型
240000Json对象型
351100变量名类型备用备注8|8|4|41|2|3|4
350000对战玩家玩家类
350000当前属性玩家属性
350000对战属性玩家属性
!!如果(玩家.开始PVP == 假)
返回(0)
""如果结束()
!!如果(玩家.PVP对象 == 0)
返回(0)
""如果结束()
 // 开始玩家与玩家之间的PK
当前属性 = 玩家.属性
 // 
!!如果(玩家.PVP挂接 == 0)
玩家.PVP挂接 = 拷贝对象(玩家.PVP对象.属性)
对战属性 = 玩家.PVP挂接
##否则
对战属性 = 玩家.PVP挂接
""如果结束()
 // 最底不能低于400ms每次攻击 也就是一秒2.5次攻击 参考LOL2.5攻速上限
!!如果(对战属性.上次攻击时间 == 未定义)
对战属性.上次攻击时间 = 0
""如果结束()
 // 
!!如果(LastTime - 对战属性.上次攻击时间 < 100 / 对战属性.攻速 * 2000 或 LastTime - 对战属性.上次攻击时间 < 400)
返回(0)
""如果结束()
 // 
对战属性.上次攻击时间 = LastTime
 // 
let hit = 1 // 玩属性.攻击 - 怪属性.物防
!!如果(hit < 1)
hit = 1
""如果结束()
 // 玩家.攻击目标 = 刷怪
当前属性.生命大 = 当前属性.生命大 - hit
 // 发送攻击包
Json = 数据Json初始化()
Json.hex = 6007
 // 包类型，怪物是受伤还是死亡 1 攻击   0 死亡
!!如果(当前属性.生命大 <= 0)
 // 怪物死亡要设置属性
Json.type = 1
 // 怪物死亡奖励
Json.info = 击杀玩家奖励(玩家, 对战玩家)
 // 怪物死亡通知
Json.str = '你被' + 对战属性.名称 + '击败了~'
 // 完结当前攻击回合
玩家.PVP对象 = 0
玩家.PVP挂接 = 0
##否则
Json.type = 0
Json.str = 当前属性.名称 + ' 受伤 生命值 - ' + hit
""如果结束()

Json.index = 4 // 被攻击序号
Json.Tndex = 5 // 发起攻击序号
 // 计算伤害
Json.hit = 当前属性.生命大
 // 攻速 客户端已经取消攻速。
Json.speed = 200
 // 推送
服务端数据发送(玩家.套接字, Json)
 // 
231000子程序名返回值类型异步公开备注1|2|3|4|5-6
230100EVP系统挂机中，如果怪物状态是有攻击类型，则会还手或者主动攻击。
241100参数名类型备用可空初始值备注1|2|3|4|5|6
240000玩家玩家类
240000LastTime数值型
240000Json对象型
 // 从玩家身上获取怪物数组，开始对怪物属性遍历 
!!如果(玩家.开始挂机 == 假)
返回(0)
""如果结束()
 // 
!!数组循环(玩家.怪物数组, i)
 // 注：与易语言不同的是 数组从0成员开始
 // 有攻击目标，后面的那些都不需要执行！
let 当前怪 = 申明自定义(当前怪物类型)
当前怪 = 玩家.怪物数组[i]
 // 当前怪物的属性。免得关联查麻烦。 怪物所有属性都基于 怪物表 自行查看
let 怪属性 = 当前怪
 // 当前玩家
let 玩属性 = 申明自定义(当前玩家属性)
 // 
玩属性 = 玩家.属性
 // 
let str = 数据Json对象到字符串(当前怪)
 // 检测两者的距离，距离够了才允许攻击。
let lx = 求绝对值(玩属性.x - 怪属性.x)
let ly = 求绝对值(玩属性.y - 怪属性.y)
 // 

!!如果(lx > 2 或 ly > 2)
 // 超出了怪物的攻击范围，这个也可以给怪物表加个攻击范围字段，这样就不会固定了，可以根据每个怪物的攻击距离来算
 // 怪物随机移动，或者根据类型来主动找玩家攻击。这里看写法，放置类就简单点。怪物随机移动，距离靠近玩家就打
!!如果(当前怪.上次移动时间 == 未定义)
当前怪.上次移动时间 = LastTime
""如果结束()
!!如果(当前怪.移动时间 == 未定义)
当前怪.移动时间 = 取随机数(1000, 2000)
""如果结束()
!!如果(LastTime - 当前怪.上次移动时间 < 当前怪.移动时间)
到循环尾()
""如果结束()
 // 
当前怪.上次移动时间 = LastTime

let 方向 = 对象取目标方向(玩家.属性.x, 玩家.属性.y, 当前怪.x, 当前怪.y)

方向 = 对象数字方向到文本(方向)
 // 不太记得方向会不会重叠了，好像重叠的默认随机了一个方向~ 这里可以自己输出看下

 // 得到了方向，根据方向计算下一步，因为服务端是点阵，步伐就1*1了。没有像素~
let 下一步 = 对象取下一步(当前怪.x, 当前怪.y, 方向, 1, 1, 1)
 // 设置怪物移动后的地方
当前怪.x = 下一步.x
当前怪.y = 下一步.y
 // 
 // 不要在意，一次就走一格子就行了，智障就智障点，太AI的复杂了，懒得写了。可以问AI写~ 
 // 服务端调试输出("怪物要移动了:" + 当前怪.名称 + "." + 当前怪.x + "." + 当前怪.y)
 // 推送移动包 对这个地图的所有玩家都发送移动包，如果是动态副本，则也要检测。玩家传送后地图ID是要改变的~ emm，加一个临时动态地图。就这样~
let Json = {}
Json.hex = 6006
Json.type = 2
Json.x = 当前怪.x
Json.y = 当前怪.y
Json.index = i
服务端数据发送(玩家.套接字, Json)

到循环尾()
""如果结束()


 // 1 根据玩家攻速来攻击怪物发送攻击频率 攻速算法 1 为1000毫秒攻速越低攻击动作越慢
!!如果(当前怪.上次攻击时间 == 未定义)
当前怪.上次攻击时间 = LastTime
""如果结束()
 // 还没有到达攻击时间，怪物继续发呆
!!如果(怪属性.攻速 == 未定义)
怪属性.攻速 = 100
""如果结束()
 // 
!!如果(LastTime - 当前怪.上次攻击时间 < 100 / 怪属性.攻速 * 2000)
到循环尾()
""如果结束()
 // 达到攻击频率
当前怪.上次攻击时间 = LastTime
服务端调试输出('怪物攻击玩家:' + 玩属性.名称 + '索引：' + i + ' 当前怪.攻速:' + 怪属性.攻速 + " x：" + lx + " y:" + ly)

 // 判断怪物是否死亡，如果死亡，则需要切换新的攻击目标
let hit = 1 // 怪物攻击玩家的
!!如果(hit < 1)
hit = 1
""如果结束()
 // 这里写个攻击公式，后面补上，一般就直接强行的随便写个攻击-防御就OK

 // 玩家.攻击目标 = 刷怪
玩属性.生命小 = 玩属性.生命小 - hit
 // 发送攻击包
Json = 数据Json初始化()
Json.hex = 6006
Json.type = 7
 // 包类型，怪物是受伤还是死亡 1 攻击   0 死亡
!!如果(玩属性.生命小 <= 0)
玩属性.生命小 = 0
 // 怪物死亡要设置属性
Json.die = 1
 // 玩家死亡惩罚 暂无 格式可以参考击杀怪物奖励反向写
 // Json.info = //击杀怪物奖励(当前玩, 当前怪)
 // 怪物死亡通知
Json.str = 玩属性.名称 + ' 被 ' + 怪属性.名称 + ' 杀死了....'

玩家.攻击目标 = 0
 // 清空这个怪物
玩家.开始挂机 = 假

##否则
Json.die = 0
Json.str = 玩属性.名称 + ' 受伤 生命值 - ' + hit
""如果结束()
 // 怪物攻击的是谁
Json.index = i // 玩家受伤 当前怪.索引 // 怪物发起
 // 计算伤害
Json.hit = hit

 // 攻速
Json.speed = 200
 // 推送
服务端数据发送(玩家.套接字, Json)
 // 设置这个怪物属性清空 玩家都死了，一了百了，通知客户端，玩家死亡状态
!!如果(玩属性.生命小 <= 0)

玩家.攻击目标 = 0
 // 清空这个怪物
玩家.开始挂机 = 假

服务端调试输出('怪物击杀了玩家，玩家没生命了~')

""如果结束()

""数组循环结束()




231000子程序名返回值类型异步公开备注1|2|3|4|5-6
230100PVE系统当玩家在挂机的状态中，怪物也会攻击玩家 这里还要看怪物属性类型是否会攻击
241100参数名类型备用可空初始值备注1|2|3|4|5|6
240000玩家玩家类
240000LastTime数值型
240000Json对象型
!!如果(玩家.开始挂机 == 假)
返回(0)
""如果结束()

 // 检测玩家是否有攻击目标
 // 服务端调试输出('玩家:' + 玩家.属性.名称 + ' - 开始挂机...')
!!如果(玩家.攻击目标 != 0)
 // 有攻击目标，后面的那些都不需要执行！
let 当前怪 = 申明自定义(当前怪物类型)
当前怪 = 玩家.攻击目标
 // 当前怪物的属性。免得关联查麻烦。 怪物所有属性都基于 怪物表 自行查看
let 怪属性 = 当前怪
 // 当前玩家
let 当前玩 = 玩家
let 玩属性 = 申明自定义(当前玩家属性)
 // 
玩属性 = 当前玩.属性
 // 
 // 检测两者的距离，距离够了才允许攻击。
let lx = 求绝对值(玩属性.x - 怪属性.x)
let ly = 求绝对值(玩属性.y - 怪属性.y)
 // 
!!如果(lx > 2 或 ly > 2)
 // 玩家攻击怪物距离超出了。要靠近选择的怪物去打

!!如果(当前玩.上次移动时间 == 未定义)
当前玩.上次移动时间 = LastTime
""如果结束()
 // 
!!如果(当前玩.移动时间 == 未定义)
当前玩.移动时间 = 取随机数(1000, 1000)
""如果结束()
 // 

!!如果(LastTime - 当前玩.上次移动时间 < 当前玩.移动时间)
返回(0)
""如果结束()
 // 
服务端调试输出("玩家在移动:" + " - " + 玩家.属性.x + " " + 玩家.属性.y + " - " + 玩属性.x + " " + 玩属性.y)
 // 
当前玩.上次移动时间 = LastTime

let 方向 = 对象取目标方向(当前怪.x, 当前怪.y, 玩家.属性.x, 玩家.属性.y)

方向 = 对象数字方向到文本(方向)
 // 不太记得方向会不会重叠了，好像重叠的默认随机了一个方向~ 这里可以自己输出看下


 // 得到了方向，根据方向计算下一步，因为服务端是点阵，步伐就1*1了。没有像素~
let 下一步 = 对象取下一步(玩属性.x, 玩属性.y, 方向, 1, 1, 1)
 // 设置怪物移动后的地方
玩属性.x = 下一步.x
玩属性.y = 下一步.y
 // 

 // 不要在意，一次就走一格子就行了，智障就智障点，太AI的复杂了，懒得写了。可以问AI写~ 
 // 推送玩家移动，走了怪物的接口
let Json = {}
Json.hex = 6006
Json.type = 6
Json.x = 玩属性.x
Json.y = 玩属性.y
服务端数据发送(玩家.套接字, Json)

返回(0)
""如果结束()

 // 1 根据玩家攻速来攻击怪物发送攻击频率 攻速算法 1 为1000毫秒攻速越低攻击动作越慢
!!如果(LastTime - 玩家.上次攻击时间 < 100 / 玩家.属性.攻速 * 2000)
返回(0)
""如果结束()
 // 达到攻击频率
玩家.上次攻击时间 = LastTime
服务端调试输出('玩家攻击怪物:' + 当前怪.名称 + '索引：' + 当前怪.index + ' 间隔:' + LastTime)
 // 判断怪物是否死亡，如果死亡，则需要切换新的攻击目标
let hit = 1 // 玩属性.攻击 - 怪属性.物防
!!如果(hit < 1)
hit = 1
""如果结束()
 // 玩家.攻击目标 = 刷怪
当前怪.生命值 =~~ 当前怪.生命值 - hit
 // 发送攻击包
Json = 数据Json初始化()
Json.hex = 6006
Json.type = 5
 // 包类型，怪物是受伤还是死亡 1 攻击   0 死亡
!!如果(怪属性.生命值 <= 0)
 // 怪物死亡要设置属性
Json.die = 1
 // 怪物死亡奖励  看用户需求，如果每个击杀都有奖励就开房这个。客户端根据需求添加物品金币等奖励渲染即可。
 // Json.info = 击杀怪物奖励(当前玩, 当前怪)
 // 怪物死亡通知
Json.str = Json.info.str
##否则
Json.die = 0
Json.str = 当前怪.名称 + ' 受伤 生命值 - ' + hit
""如果结束()
 // 攻击的那个怪物
Json.index = 当前怪.index // 收到攻击
 // Json.Tndex = 4 // 发起攻击 4是玩家自身
 // 计算伤害
Json.hit = hit
 // 攻速
 // Json.speed = 200
 // 推送
服务端数据发送(玩家.套接字, Json)
 // 设置这个怪物属性清空
!!如果(当前怪.生命值 <= 0)
玩家.怪物数组[Json.index] = {}
玩家.攻击目标 = 0
 // 清空这个怪物
键值['' + Json.index] = LastTime

""如果结束()


""如果结束()
 // 否则寻找新的怪物攻击 随机给个怪物攻击。  // 这里找怪我就随机的。
!!如果(玩家.怪物数组.#长度 == 0)
提示核心(玩家.套接字, "当前地图没有怪物了", )
返回(0)
""如果结束()

let index = 取随机数(0, 玩家.怪物数组.#长度 - 1)
 // 
let 刷怪 = 申明自定义(刷怪类型)
刷怪 = 玩家.怪物数组[index]

 // 从怪物数组中抽取一个出来，判断它的属性 怪物是通过脚本那边生成的，属性如下，如有修改自行补充这里注释，方便查询
 // 怪物对象.id = 怪物ID
 // 怪物对象.地图ID = 地图ID
 // 怪物对象.x = 随机x
 // 怪物对象.y = 随机y
 // 怪物对象.复活时间 = 复活时间
 // 怪物对象.名称 = 怪物.名称
 // 怪物对象.攻速 = 怪物.攻速
 // 怪物对象.外观 = 怪物.外观
 // 怪物对象.生命值 = 怪物.血量
 // 怪物对象.index = i
 // 怪物死了重新锁定怪物

 // ///////////////////////以下是复活怪物，已经修改为脚本内置功能，看刷怪多少只小怪，会自动计数刷出/////////////////
 // Json = 数据Json初始化()
 // Json.hex = 6006
 // Json.type = 3
 // Json.index = index
 // Json.info = 刷怪.属性
 // 服务端数据发送(玩家.套接字, Json)


!!如果(刷怪.生命值 > 0)
 // 或者的怪物就可以让玩家锁定
!!如果(玩家.攻击目标 == 0)
 // 设置初始攻击目标  // 设置当前玩家攻击目标
玩家.攻击目标 = 刷怪
""如果结束()

""如果结束()


231000子程序名返回值类型异步公开备注1|2|3|4|5-6
230100击杀怪物奖励对象型给客户端展现的掉落
241100参数名类型备用可空初始值备注1|2|3|4|5|6
240000玩家玩家类
240000怪物当前怪物类型
351100变量名类型备用备注8|12|4|41|2|3|4
350000Json奖励包
350000怪物属性当前怪物属性
350000玩家属性当前玩家属性
350000刷怪属性当前刷怪属性
 // 怪物死亡，给与玩家奖励
玩家属性 = 玩家.属性
怪物属性 = 怪物.属性
刷怪属性 = 怪物属性.刷怪属性
 // 
玩家属性.经验 =~~ 玩家属性.经验 +~~ 怪物属性.经验值 * 经验倍数
 // 
let 升级经验 = 经验表判断(玩家属性.等级)

!!如果(玩家属性.经验 >= 升级经验 且 升级经验 != 0)
 // 数据等级+1
玩家属性.等级 ++ 
 // 等级只有升级时候才会有
Json.lev = 玩家属性.等级
 // 经验计算剩余
玩家属性.经验 =~~ 玩家属性.经验 -~~ 升级经验
 // 注意，如果升级了，正常来说，最大生命也会跟着涨，当前生命也会看需求是否恢复部分

""如果结束()

Json.exp = 玩家属性.经验 // 当前经验
 // 需求经验
Json.uexp = 升级经验
 // 
Json.lev = 玩家属性.等级 // 当前等级
 // 增加金币
let 金币 = 取随机数(刷怪属性.最少金币, 刷怪属性.最多金币)
let 概率 = 取随机数(1, 10000)
!!如果(概率 <= 刷怪属性.爆率金币)
玩家属性.金币 = 玩家属性.金币 + 金币
""如果结束()
Json.money = 玩家属性.金币
 // 掉落物品列表
let 奖励数组 = 掉落表怪物死亡奖励(刷怪属性.爆率ID)
 // 掉落物品列表
Json.drop = []
 // 添加到玩家背包中.
!!数组循环(奖励数组, i)
 // 注：与易语言不同的是 数组从0成员开始
let droplist = {} // 掉落对象
droplist.itemid = 奖励数组[i] // 掉落物品ID
 // 物品流水ID
droplist.id = 玩家.物品添加(奖励数组[i])
 // 物品查询
let item = 物品基础查找(奖励数组[i])
!!如果(item == 0)
到循环尾()
##否则
droplist.lookface = item.图标
 // 包裹没有满曝出的东西
!!如果(droplist.id > 0)
数组加入成员末尾(Json.drop, droplist)
""如果结束()
""如果结束()
""数组循环结束()

服务端调试输出('怪物死亡:' + 怪物属性.名称 + '-玩家等级' + 玩家属性.等级 + ' 经验' + 玩家属性.经验 + '/' + 升级经验 + ' 掉落金币+' + 金币 + '掉落概率:' + 刷怪属性.爆率金币 + ' 当前概率:' + 概率 + ' 物品规则ID:' + 刷怪属性.爆率ID + ' 物品数量:' + 奖励数组.#长度)
 // 附加当前
Json.str = '击杀：' + 怪物属性.名称 + ' 获得： 经验' + 怪物属性.经验值 * 经验倍数 + '  金币：' + 金币

返回(Json)



231000子程序名返回值类型异步公开备注1|2|3|4|5-6
230100击杀玩家奖励对象型给客户端展现的掉落
241100参数名类型备用可空初始值备注1|2|3|4|5|6
240000玩家玩家类
240000被击玩家玩家类
351100变量名类型备用备注12|12|4|41|2|3|4
350000Json奖励包
350000击杀玩家属性当前怪物属性
350000玩家属性当前玩家属性
350000刷怪属性当前刷怪属性
 // 怪物死亡，给与玩家奖励
玩家属性 = 玩家.属性
击杀玩家属性 = 被击玩家.属性
 // 
玩家属性.经验 = 玩家属性.经验 + 0
 // 
let 升级经验 = 经验表判断(玩家属性.等级)

Json.exp = 玩家属性.经验 // 当前经验
 // 需求经验
Json.uexp = 升级经验
 // 
Json.lev = 玩家属性.等级 // 当前等级
 // 增加金币 这里可以从被挑战的玩家身上扣除金币
let 金币 = 100
玩家属性.金币 = 玩家属性.金币 + 金币
Json.money = 玩家属性.金币
 // 掉落物品列表
Json.drop = []
 // 如果有需求掉落物品就调用以下代码
 // 被击玩家.物品转移背包(玩家)
 // 设定积分
玩家属性.积分 += 1
 // 可以放在下线地方
玩家数据修改(玩家属性.id, '积分', 玩家属性.积分)
 // 
返回(Json)





