171000程序集名备注8|121|2-3-4
170100数据处理处理数据服务

231000子程序名返回值类型异步公开备注1|2|3|4|5-6
230100服务端数据发送将消息序列化发送到服务端
241100参数名类型备用可空初始值备注1|2|3|4|5|6
240000ID数值型
240000Json对象型注意，是Json对象格式并非文本
let arr = 消息序列.正序列化(Json)
arr = 到文本(arr)
服务端发送(ID, arr)
231000子程序名返回值类型异步公开备注1|2|3|4|5-6
230100提示核心对客户端发送一个提示信息框 
241100参数名类型备用可空初始值备注1|2|3|4|5|6
240000ID数值型
240000text文本型
240000title数组型用于按钮提示 ['好吧']
let Json  = 数据Json初始化()
Json.hex = '消息提示'
Json.type = 1
Json.text = text
!!如果(title == 未定义)
title = ['好吧']
""如果结束()

Json.title = title
服务端数据发送(ID, Json)

231000子程序名返回值类型异步公开备注1|2|3|4|5-6
230100队伍消息推送服务端的队伍操作，对客户端推送
241100参数名类型备用可空初始值备注1|2|3|4|5|6
240000ID数值型
240000消息文本型如果不是空则会弹出客户消息
240000type数值型根据当前类型来执行不同操作，留空则仅仅提示
240000obj对象型附加参数
let Json = 数据Json初始化()
Json.hex = 2100
Json.type = type
Json.title = 消息
Json.obj = obj
服务端数据发送(ID, Json)
231000子程序名返回值类型异步公开备注1|2|3|4|5-6
230100玩家登录
241100参数名类型备用可空初始值备注1|2|3|4|5|6
240000ID数值型
240000Json登录数据
351100变量名类型备用备注6|6|4|41|2|3|4
350000index数值型
350000玩家玩家类

 // 检测账号密码传递过来是否异常
!!如果(Json.acc == 未定义 或 Json.acc == '')
提示核心(ID, '请输入账号')
返回(0)
""如果结束()
!!如果(Json.pass == 未定义 或 Json.pass == '')
提示核心(ID, '请输入密码')
返回(0)
""如果结束()
 // 新用户登录时候，检测数组中是否有空房间，如果有则直接赋值，没有则创建
index = 玩家查找账号(Json.acc)
!!如果(index !=  - 1)
提示核心(ID, '当前账号已经登录~')
返回(0)
""如果结束()
 // 查询是否还有空房间
index = 玩家查找(0)
!!如果(index ==  - 1)
 // 没有
玩家 = 新建对象(玩家类, )
 // 加入到数组中
数组加入成员末尾(数组玩家, 玩家)
##否则
 // 
玩家 = 数组玩家[index]
""如果结束()
 // 查询数据库
let Sql = 文本替换(数据配置.账号查询, '#zhanghao', Json.acc)
 // 无论成失败都只会返回Json数据
let Ret = 数据库执行(Sql, 1)
 // 转到Json配置
let Sjson = 数据Json字符串到对象(Ret)
 // 检测账号是否存在
!!如果(Sjson.errcode != 200)
提示核心(ID, '数据库异常')
返回(0)
""如果结束()
let 账号数量 = 数组取成员数(Sjson.data)
!!如果(账号数量 == 0)
提示核心(ID, '当前账号不存在')
返回(0)
""如果结束()
 // 当前玩家的账号对象
let 账号数据 = 申明自定义(账号类型)
账号数据.id = 0 // 账号id
账号数据.zhanghao = 0 // 账号
账号数据.mima = 0 // 密码
账号数据.youxiang = 0 // 超级密码
 // 赋值
账号数据 = Sjson.data[0]
 // 
!!如果(账号数据.mima != 未定义 且 账号数据.mima != Json.pass)
提示核心(ID, '账号与密码不匹配')
返回(0)
""如果结束()
 // 绑定账号ID，读取到了账号ID要写到玩家类绑定起来，让玩家这个类知道它属于那个账号
玩家.accountid = 账号数据.id
玩家.acc = Json.acc
 // 记录套接字
玩家.套接字 = ID
 // 开始读取角色，判断是否存在
玩家获取角色(ID, 账号数据.id)

231000子程序名返回值类型异步公开备注1|2|3|4|5-6
230100玩家获取角色获取当前账号ID下的角色
241100参数名类型备用可空初始值备注1|2|3|4|5|6
240000ID数值型
240000账号ID文本型
351100变量名类型备用备注8|6|4|41|2|3|4
350000是否新建数值型
 // 
Sql = 文本替换( 数据配置.角色查找 ,'#accountid'  , 账号ID)
 // 无论成失败都只会返回Json数据
Ret = 数据库执行(Sql, 1)
 // 服务端调试输出('---' + 账号ID + Ret)
 // 转到Json配置
Sjson = 数据Json字符串到对象(Ret)
 // 检测账号是否存在
!!如果(Sjson.errcode != 200)
提示核心(ID, '数据库异常')
返回(0)
""如果结束()
!!如果(Sjson.data[0] == 未定义)
 // 提示核心(ID, '当前没有角色')
推送_创建角色面板(ID)

返回(0)
""如果结束()
是否新建 = 1
 // 获取玩家物品数据 这是原生的数据库字段配置，所以要使用时候必须用字段
let 角色数据 = Sjson.data[0]
 // 补充一些内存数据
let 升级经验 = 经验表判断(角色数据.等级)
 // 仅提供给首次上线用户使用 
角色数据.升级经验 = 升级经验
 // 获取玩家物品数据
Sql = 文本替换( 数据配置.装备获取 ,'#userid'  , 角色数据.id)
 // 无论成失败都只会返回Json数据
Ret = 数据库执行(Sql, 1)
 // 服务端调试输出("查询物品：" + Ret)
 // 转到Json配置
Sjson = 数据Json字符串到对象(Ret)
 // 物品数据库查询失败，拒绝登录。
!!如果(Sjson.errcode != 200)
提示核心(ID, '物品数据异常')
返回(0)
""如果结束()
 // 物品不管有没有都记录
let 玩家物品 = Sjson.data

 // 技能获取
Sql = 文本替换( 数据配置.技能获取 ,'#id'  , 角色数据.id)
 // 无论成失败都只会返回Json数据
Ret = 数据库执行(Sql, 1)
 // 服务端调试输出("查询物品：" + Ret)
 // 转到Json配置
Sjson = 数据Json字符串到对象(Ret)
 // 物品数据库查询失败，拒绝登录。
!!如果(Sjson.errcode != 200)
提示核心(ID, '技能数据异常')
返回(0)
""如果结束()
 // 物品不管有没有都记录
let 玩家技能 = Sjson.data


 // 正式进入登录 将当前数据写到玩家类中
玩家进入(ID, 角色数据, 玩家物品)
 // 
 // 这里数据看情况都组合一起发过去。
let 推送数据 = 数据Json初始化()
推送数据.hex = 1000
推送数据.type = 是否新建
 // 当前玩家一个账号下可能会有多个角色，都放过去  当前游戏默认一个账号一个角色
推送数据.userinfo = 角色数据
 // 推送玩家物品时候并非所有数据，仅仅只需要传入 物品流水ID，外观即可。如果有数量需求那就继续添加一个参数传递
let 推送物品 = []
!!数组循环(玩家物品, i)
 // 注：与易语言不同的是 数组从0成员开始
let item = {}
 // 通过物品ID找到基础物品属性
let 物品基础属性 = 物品基础查找(玩家物品[i].物品ID)
!!如果(物品基础属性 == 0)
到循环尾()
""如果结束()
 // 传个流水号
item.id = 玩家物品[i].id
item.pos = 玩家物品[i].位置
 // 图标
item.lookface = 物品基础属性.图标
 // 
数组加入成员末尾(推送物品, item)
""数组循环结束()
 // 
推送数据.zhuangbei = 推送物品
 // 商城数据
推送数据.shangcheng = 系统配置.商城配置
 // 推送技能
推送数据.jineng = 玩家技能
 // 当前物品
服务端数据发送(ID, 推送数据)
 // 玩家还有进入地图事件
玩家进入地图(ID, 角色数据.地图ID)

231000子程序名返回值类型异步公开备注1|2|3|4|5-6
230100玩家进入地图进入新的地图，会删除当前地图所有的NPC，怪物等信息，进入新的地图重新加载 0失败 同地图不让传送，自己另外写个，因为同地图只需要客户端改坐标就行了。
241100参数名类型备用可空初始值备注1|2|3|4|5|6
240000ID数值型套接字
240000地图ID数值型地图ID
240000x数值型如果带了值，则强制玩家修改坐标
240000y数值型如果带了值，则强制玩家修改坐标
240000动态逻辑型是否进入动态副本
351100变量名类型备用备注6|6|4|41|2|3|4
350000Index数组型
350000玩家玩家类
服务端调试输出('玩家进入地图：' + 地图ID)
Index = 玩家查找(ID)
!!如果(Index ==  - 1)
返回(0)
""如果结束()
 // 
玩家 = 数组玩家[Index]
 // 
let 推送数据 = 数据Json初始化()
推送数据.hex = "传送地图" // 推送进入地图
 // 查找当前要传送的地图信息
let 地图配置 = 地图表查找(地图ID)
!!如果(地图配置 == 0)
提示核心(ID, '地图并不存在:' + 地图ID)
返回(0)
""如果结束()
推送数据.地图信息 = 地图配置
 // 当前地图的NPC也推送上去
let NPC配置 = NPC获取当前地图(地图ID)
推送数据.NPC信息 = NPC配置
 // 当前刷怪点 客户端可以在当前地图传送的  副本都是独立的。每个人传送地图后，怪物都只能自己看到。队伍的模式，就刷在队长身上，怪物会捆绑在队伍上
 // 这里必须是传送地图，进入副本才会获取怪物的。后面改下先测试
 // let 刷怪配置 = 刷怪获取当前地图(地图ID)
 // 
推送数据.刷怪信息 = []
 // 这里要绑定，进入地图后，它所有的怪物数据，玩家进入战斗组时候最好是通过脚本上控制刷怪
玩家.怪物数组 = []
 // 
 // 获取周围玩家
推送数据.网玩数组 = 玩家获取同地图(ID, 地图ID)

 // 是否修改坐标 如果传送则需要修改坐标
推送数据.坐标 = (x == 未定义)? 假: 真; 
推送数据.x = x
推送数据.y = y
 // 推送给客户端。
 // 
推送数据.副本 = 玩家.副本
 // 记录副本时间
推送数据.倒计时 = 玩家.倒计时
 // 记录回城ID

服务端数据发送(ID, 推送数据)

 // 将自己上线的信息，推送给其他玩家 之所以这样做，是因为像过滤部分数据。
let 传递对象 = {}
传递对象.hex = 4000
传递对象.type = 2
传递对象.x = (x == 未定义)? 玩家.属性.x: x; 
传递对象.y = (y == 未定义)? 玩家.属性.y: y; 
传递对象.生命小 = 玩家.属性.生命小
传递对象.生命大 = 玩家.属性.生命大
传递对象.id = 玩家.属性.id // 玩家id
传递对象.名称 = 玩家.属性.名称
传递对象.等级 = 玩家.属性.等级
传递对象.index = Index
传递对象.套接字 = ID

 // 将自己的信息，告诉当前地图其他所有人。如有需求自行添加坐标检测
!!数组循环(推送数据.网玩数组, i)
 // 注：与易语言不同的是 数组从0成员开始
服务端数据发送(推送数据.网玩数组[i].套接字, 传递对象)

""数组循环结束()



返回(1)

231000子程序名返回值类型异步公开备注1|2|3|4|5-6
230100登录创建角色
241100参数名类型备用可空初始值备注1|2|3|4|5|6
240000ID数值型
240000Json创建角色包
351100变量名类型备用备注8|6|4|41|2|3|4
350000Sql文本型
350000查询结果文本型
350000性别文本型
350000职业文本型
350000名称文本型
350000索引数值型
350000玩家玩家类
 // 检测是否登录成功
索引 = 玩家查找(ID)
 // 
!!如果(索引 ==  - 1)
提示核心(ID, '非法操作0x001')
返回(0)
""如果结束()
 // // 
玩家 = 数组玩家[索引]
 // 第一步，检测是否存在重名玩家！
 // 第二部，检测Json要使用的成员是否存在！！！
!!如果(Json.name == 未定义 或 Json.job == 未定义 或 Json.sex == 未定义 或 Json.name == '')
提示核心(ID, '错误的注册信息')
返回(0)
""如果结束()
 // 
Sql = 格式化文本(数据配置.角色名查询, Json.name)
 // 
查询结果 = 数据库执行(Sql, 假)
 // 
服务端调试输出("登录角色名查询:" + 查询结果)
 // 
查询结果 = 数据Json字符串到对象(查询结果)
 // 
!!如果(查询结果.errcode != 200)
提示核心(ID, '错误代码0x0003')
返回(0)
""如果结束()

!!如果(查询结果.data[0] != 未定义)
提示核心(ID, '该角色名已存在')
返回(0)
""如果结束()
 // 一切校验通过，新插入信息 性别职业选择
名称 = Json.name
性别 == 选择(Json.sex == 性别男, 性别男, 性别女)
职业 == 选择(Json.job == 职业法师, 职业法师, 职业战士)
 // 找到玩家登录时候获取到的基本账号信息，然后写入到角色表关联
Sql = 格式化文本(数据配置.角色插入, 名称\\职业\\性别\\玩家.accountid)
 // 
服务端调试输出("角色添加sql:" + Sql)

 // 
查询结果 = 数据库执行(Sql, 假)
 // 
服务端调试输出("登录角色名查询:" + 查询结果)
 // 
查询结果 = 数据Json字符串到对象(查询结果)
 // 
!!如果(查询结果.errcode != 200)
提示核心(ID, '错误代码0x0004')
返回(0)
""如果结束()
 // 创建角色OK了，重新跳转到获取角色命令。继续登录~~~
玩家获取角色(ID, 玩家.accountid)

231000子程序名返回值类型异步公开备注1|2|3|4|5-6
230100账号密码修改修改账号的密码，需要验证旧密码
241100参数名类型备用可空初始值备注1|2|3|4|5|6
240000ID数值型玩家套接字
240000账号文本型账号
240000旧密码文本型旧密码
240000新密码文本型新密码
351100变量名类型备用备注8|6|4|141|2|3|4
350000Sql文本型SQL 语句
350000执行结果文本型数据库执行结果
350000数据对象对象型JSON 数据对象
 // 检查账号和密码是否为空
!!如果(账号 == 未定义 或 账号 == '')
提示核心(ID, '账号不能为空', )
返回(0)
""如果结束()
!!如果(旧密码 == 未定义 或 旧密码 == '')
提示核心(ID, '旧密码不能为空', )
返回(0)
""如果结束()
!!如果(新密码 == 未定义 或 新密码 == '')
提示核心(ID, '新密码不能为空', )
返回(0)
""如果结束()
 // 查询账号是否存在
Sql = 文本替换(数据配置.账号查询, '#zhanghao', 账号)
执行结果 = 数据库执行(Sql, 1)
数据对象 = 数据Json字符串到对象(执行结果)
 // 检查账号是否存在
!!如果(数据对象.errcode != 200)
提示核心(ID, '数据库异常', )
返回(0)
""如果结束()
!!如果(数据对象.data == 未定义 或 数据对象.data.#长度 == 0)
提示核心(ID, '账号不存在', )
返回(0)
""如果结束()
 // 检查旧密码是否正确
let 账号数据 = 数据对象.data[0]
!!如果(账号数据.mima != 旧密码)
提示核心(ID, '旧密码错误', )
返回(0)
""如果结束()
 // 修改密码
Sql = 文本替换(数据配置.账号密码修改, '#新密码', 新密码)
Sql = 文本替换(Sql, '#账号', 账号)
执行结果 = 数据库执行(Sql, 1)
数据对象 = 数据Json字符串到对象(执行结果)
 // 检查是否修改成功
!!如果(数据对象.errcode != 200)
提示核心(ID, '密码修改失败，数据库异常', )
返回(0)
""如果结束()
 // 提示成功
提示核心(ID, '密码修改成功', )
返回(1)
231000子程序名返回值类型异步公开备注1|2|3|4|5-6
230100玩家注册
241100参数名类型备用可空初始值备注1|2|3|4|5|6
240000ID数值型
240000Json对象型
!!如果(Json.acc == 未定义 或 Json.pass == 未定义 或 Json.spass == 未定义 或 Json.email == 未定义)
 // 返回客户通提示信息框
提示核心(ID, '当前注册信息错误')
返回(0)
""如果结束()
 // 都存在
!!如果(Json.acc.#长度 < 1 或 Json.pass.#长度 < 1)
提示核心(ID, '账号密码过短')
返回(0)
""如果结束()
 // 
!!如果(Json.pass !== Json.spass)
提示核心(ID, '两次密码不一致')
返回(0)
""如果结束()

 // 查询数据库
let Sql = 数据配置.账号查询
Sql = 文本替换( Sql , '#zhanghao' ,Json.acc )
let ret = 数据库执行(Sql, 1)

服务端调试输出(ret)

let 账号对象 = 数据Json字符串到对象(ret)
!!如果(账号对象.errcode != 200)
提示核心(ID, '数据异常')
返回(0)
""如果结束()
 // 
!!如果(账号对象.data[0] != 未定义)
提示核心(ID, '账号已经存在')
返回(0)
""如果结束()


 // 写入数据库
Sql = 数据配置.账号添加
服务端调试输出('执行SQL语句:' + Sql)
 // 替换要写入的
Sql = 文本替换( Sql , '#zhanghao' ,Json.acc )
Sql = 文本替换( Sql , '#mima' ,Json.pass )
Sql = 文本替换( Sql , '#youxiang' ,Json.email)
Sql = 文本替换( Sql , '#chaoma' ,Json.spass )
ret = 数据库执行(Sql, 1)
服务端调试输出('添加账号结果:' + ret)
 // 
Json = 数据Json字符串到对象(ret)

!!如果(Json.errcode != 200)
提示核心(ID, '账号注册异常')
返回(0)
""如果结束()

提示核心(ID, '注册成功')


231000子程序名返回值类型异步公开备注1|2|3|4|5-6
230100玩家开启战斗
241100参数名类型备用可空初始值备注1|2|3|4|5|6
240000ID数值型
240000Json对象型
351100变量名类型备用备注6|6|4|41|2|3|4
350000Index数值型
350000玩家玩家类
Index = 玩家查找(ID)
!!如果(Index ==  - 1)
返回(0)
""如果结束()
玩家 = 数组玩家[Index]
 // 通知线程，当前玩家进入了攻击状态
!!如果(玩家.属性.生命小 <= 0)
提示核心(ID, '请阁下复活后再来吧~', )
返回(0)
""如果结束()

玩家.开始挂机 = 真
玩家.攻击目标 = 0
玩家.刷怪初始化()

服务端调试输出('玩家:' + 玩家.属性.名称 + ' -开始战斗')
返回(0)

231000子程序名返回值类型异步公开备注1|2|3|4|5-6
230100玩家停止战斗
241100参数名类型备用可空初始值备注1|2|3|4|5|6
240000ID数值型
240000Json对象型
351100变量名类型备用备注6|6|4|41|2|3|4
350000Index数值型
350000玩家玩家类
Index = 玩家查找(ID)
!!如果(Index ==  - 1)
返回(0)
""如果结束()
玩家 = 数组玩家[Index]
 // 通知线程，当前玩家进入了攻击状态
玩家.开始挂机 = 假
玩家.攻击目标 = 0
玩家.刷怪初始化()
服务端调试输出('玩家:' + 玩家.属性.名称 + ' -停止战斗')
返回(0)


231000子程序名返回值类型异步公开备注1|2|3|4|5-6
230100玩家击杀怪物已经取消，不再从客户端获取状态
241100参数名类型备用可空初始值备注1|2|3|4|5|6
240000ID数值型
240000Json对象型
351100变量名类型备用备注6|6|4|41|2|3|4
350000Index数值型
350000玩家玩家类
Index = 玩家查找(ID)
!!如果(Index ==  - 1)
返回(0)
""如果结束()
 // 返回消息
Json = 数据Json初始化()
Json.hex = 6006
 // 挂接物品奖励
服务端数据发送(ID, Json)
 // 服务端的线程开启冒险触发事件

231000子程序名返回值类型异步公开备注1|2|3|4|5-6
230100玩家开启探险客户端开启挑战系统，服务端开始处理逻辑。
241100参数名类型备用可空初始值备注1|2|3|4|5|6
240000ID数值型
240000Json对象型
351100变量名类型备用备注6|6|4|41|2|3|4
350000Index数值型
350000玩家玩家类
Index = 玩家查找(ID)
!!如果(Index ==  - 1)
返回(0)
""如果结束()
 // 
玩家 = 数组玩家[Index]
 // 返回消息
Json = 数据Json初始化()
Json.hex = 6004
Json.怪物列表 = 玩家.怪物数组
服务端数据发送(ID, Json)
 // 服务端的线程开启冒险触发事件

231000子程序名返回值类型异步公开备注1|2|3|4|5-6
230100玩家复活
241100参数名类型备用可空初始值备注1|2|3|4|5|6
240000ID数值型
240000Json对象型
351100变量名类型备用备注6|6|4|41|2|3|4
350000Index数值型
350000玩家玩家类
Index = 玩家查找(ID)
!!如果(Index ==  - 1)
返回(0)
""如果结束()
 // 
玩家 = 数组玩家[Index]

 // 玩家.数据.复活方式 = Json.type
 // 玩家.数据.复活确定 = 真
 //  // 点击免费复活按钮才开始计时 如果在死亡就开始计时，屏蔽即可
 // 玩家.数据.死亡时间  = 取时间戳()
 //  // 如果选择免费复活方式则需要对客户端恢复一个创建倒计时
!! // 如果(玩家.数据.复活方式 == 1)
 // Json = {}
 // Json.hex = 1004
 // Json.time = 到整数(玩家.数据.复活时间 / 1000)
 // 服务端数据发送(ID, Json)
"" // 如果结束()
 // 
 // 服务端调试输出('玩家提交复活方式:' + 玩家.数据.复活方式 + ' ' + 玩家.数据.生命最小)

231000子程序名返回值类型异步公开备注1|2|3|4|5-6
230100玩家使用道具无论穿戴装备还是使用道具都会通过这个地方处理
241100参数名类型备用可空初始值备注1|2|3|4|5|6
240000ID数值型
240000Json对象型
351100变量名类型备用备注6|6|4|41|2|3|4
350000Index数值型
350000玩家玩家类
Index = 玩家查找(ID)
!!如果(Index ==  - 1)
返回(0)
""如果结束()
 // 
玩家 = 数组玩家[Index]
 // 
let 装备流水ID = Json.id
!!如果(装备流水ID == 未定义)
提示核心(ID, "物品不存在0x01", )

返回(0)
""如果结束()
 // 通过不同标记操作
!!如果(Json.type == 2)
玩家.物品使用(装备流水ID, Json)
#*否则如果(Json.type == 1)
玩家.装备穿戴(装备流水ID)
#*否则如果(Json.type == 3)
玩家.装备脱下(装备流水ID)
#*否则如果(Json.type == 4)
玩家.装备锻造(Json)
#*否则如果(Json.type == 5)
玩家.存放仓库(装备流水ID)
#*否则如果(Json.type == 6)
玩家.取出仓库(装备流水ID)
#*否则如果(Json.type == 7)
玩家.购买道具(装备流水ID)
#*否则如果(Json.type == 8)
 // 锻造的时候放入道具
玩家.放入道具(装备流水ID)


""如果结束()




231000子程序名返回值类型异步公开备注1|2|3|4|5-6
230100玩家查看道具
241100参数名类型备用可空初始值备注1|2|3|4|5|6
240000ID数值型
240000Json对象型
351100变量名类型备用备注6|6|4|41|2|3|4
350000Index数值型
350000玩家玩家类
Index = 玩家查找(ID)
!!如果(Index ==  - 1)
返回(0)
""如果结束()
 // 
玩家 = 数组玩家[Index]
 // 
let 装备流水ID = Json.id
let 是否锻造 = Json.Upstar
服务端调试输出("查看装备ID：" + 装备流水ID)
!!如果(装备流水ID == 未定义 或 是否锻造 == 未定义)
返回(0)
""如果结束()
 // 先检测这个物品是否属于这个玩家
玩家.物品查看(装备流水ID, 是否锻造)


231000子程序名返回值类型异步公开备注1|2|3|4|5-6
230100玩家查看排行
241100参数名类型备用可空初始值备注1|2|3|4|5|6
240000ID数值型
240000Json对象型
351100变量名类型备用备注8|6|4|41|2|3|4
350000玩家数组数组型
350000排序数组数组型
350000类型文本型
 // 查看排行两个方案，type=1 等级 =2 则为积分
类型 = '等级'
!!如果(Json.str == '级')
类型 = '等级'
#*否则如果(Json.str == '积')
类型 = '积分'
""如果结束()

玩家数组 = 排行榜获取人物(ID)
排序数组 = 数组特殊排序(玩家数组, 类型)
let 哈哈哈 = 数据Json对象到字符串(排序数组)

let Tjson = {}
Tjson.Hex = 2008
Tjson.list = 排序数组
Tjson.type = 类型
服务端数据发送(ID, Tjson)


231000子程序名返回值类型异步公开备注1|2|3|4|5-6
230100玩家查看商品
241100参数名类型备用可空初始值备注1|2|3|4|5|6
240000ID数值型
240000Json对象型
351100变量名类型备用备注6|6|4|41|2|3|4
350000Index数值型
350000玩家玩家类
350000str数组型
Index = 玩家查找(ID)
!!如果(Index ==  - 1)
返回(0)
""如果结束()
 // 
let 商城ID = Json.id
!!如果(商城ID == 未定义)
返回(0)
""如果结束()
 // 先检测这个物品是否属于这个玩家
let 商城物品 = 商城表查找(商城ID)
let nJson = 数据Json初始化()
nJson.type = 1
nJson.size = 28
nJson.value = 商城物品.名称
数组加入成员末尾(str, nJson)
 // 图标
nJson = {}
nJson.type = 2
nJson.value = 'item' + 商城物品.图标
数组加入成员末尾(str, nJson)
 // 线条
nJson = {}
nJson.type = 3
数组加入成员末尾(str, nJson)
 // 物品提示
nJson = {}
nJson.type = 6
nJson.size = 24
nJson.value = 商城物品.描述
数组加入成员末尾(str, nJson)
 // 线条
nJson = {}
nJson.type = 3
数组加入成员末尾(str, nJson)

 // 添加卖出信息
nJson = {}
nJson.type = 4
nJson.size = 24
 // 显示价格 // 判断售卖物品价值，来决定是否警告
!!如果(商城物品.价格 == 未定义 或 商城物品.价格 == 0)
 // 强制卖1金币
商城物品.价格 = 1
""如果结束()
 // 
nJson.value = '价格:  ' + 商城物品.价格
数组加入成员末尾(str, nJson)
 // 
nJson = {}
nJson.type = 5
nJson.value = '购买'
nJson.size = 24
数组加入成员末尾(str, nJson)
 // 200为道具
nJson = {}
nJson.type = 5
nJson.value = '关闭'
nJson.size = 24
数组加入成员末尾(str, nJson)

 // 组包
Json = {}
Json.hex = 2002
Json.str = str
服务端数据发送(ID, Json)

231000子程序名返回值类型异步公开备注1|2|3|4|5-6
230100玩家卖出道具
241100参数名类型备用可空初始值备注1|2|3|4|5|6
240000ID数值型
240000Json对象型
351100变量名类型备用备注6|6|4|41|2|3|4
350000Index数值型
350000玩家玩家类
Index = 玩家查找(ID)
!!如果(Index ==  - 1)
返回(0)
""如果结束()
 // 
玩家 = 数组玩家[Index]
 // 
let 装备流水ID = Json.id
服务端调试输出("卖出ID：" + 装备流水ID)
!!如果(装备流水ID == 未定义)
返回(0)
""如果结束()
玩家.物品卖出(装备流水ID)

231000子程序名返回值类型异步公开备注1|2|3|4|5-6
230100玩家获取附近
241100参数名类型备用可空初始值备注1|2|3|4|5|6
240000ID数值型
240000Json对象型
351100变量名类型备用备注6|6|4|41|2|3|4
350000Index数值型
350000玩家玩家类
Index = 玩家查找(ID)
!!如果(Index ==  - 1)
返回(0)
""如果结束()
 // 
玩家 = 数组玩家[Index]
 // 获取与玩家同地图的玩家 推送给客户端
Json = {}
Json.hex = 4000
Json.List = []
!!数组循环(数组玩家, i)
 // 注：与易语言不同的是 数组从0成员开始
let player = 申明自定义(玩家类)
player = 数组玩家[i]
let 结构 = {}
结构.id = player.数据.角色ID
结构.name = player.数据.玩家名称
结构.lev = player.数据.等级
结构.str = '谁来战我~'
 // 排除自己
!!如果(结构.name == 玩家.数据.玩家名称)
到循环尾()
""如果结束()
数组加入成员末尾(Json.List, 结构)
""数组循环结束()
 // 
服务端数据发送(ID, Json)



231000子程序名返回值类型异步公开备注1|2|3|4|5-6
230100玩家获取排行榜
241100参数名类型备用可空初始值备注1|2|3|4|5|6
240000ID数值型
240000Json对象型
351100变量名类型备用备注6|6|4|41|2|3|4
350000Index数值型
350000玩家玩家类
Index = 玩家查找(ID)
!!如果(Index ==  - 1)
返回(0)
""如果结束()
 // 
玩家 = 数组玩家[Index]
 // 获取与玩家同地图的玩家 推送给客户端
Json = {}
Json.hex = 5000
Json.List = []
 // 这里可以从数据库获取要排行的类型。这里暂时没处理。一般来说获取等级就够了
let str = 数据库执行(数据配置.玩家排行, 0)
服务端调试输出(str)
 // 转到Json配置
let Sjson = 数据Json字符串到对象(str)
 // 检测账号是否存在
!!如果(Sjson.errcode != 200)
提示核心(ID, '数据库异常')
返回(0)
""如果结束()
 // 先从内存获取
let 投递数组 = Sjson.data

!!数组循环(投递数组, i)
 // 注：与易语言不同的是 数组从0成员开始
let player = 申明自定义(玩家属性)
 // {"errcode": 200, "errmsg": "success", "data": [{"id": 1, "name": "流云思水", "mapid": 100, "lev": 3, "y": 13, "minlife": 4, "maxlife": 100, "tiekuang": 10, "vip": 0, "exp": 118, "money": 352, "emoney": 823, "job": 1, "sex": 0, "accountid": 1}, {"id": 2, "name": "55IDE.Com", "mapid": 100, "lev": 1, "y": 0, "minlife": 0, "maxlife": 100, "tiekuang": 10, "vip": 0, "exp": 3, "money": 0, "emoney": 0, "job": 1, "sex": 0, "accountid": 2}], "ID": ""}
player = 投递数组[i]
let 结构 = {}
结构.id = player.id
结构.name = player.name
结构.lev = player.lev
结构.str = '等级为王~'
数组加入成员末尾(Json.List, 结构)
""数组循环结束()
 // 
服务端数据发送(ID, Json)


231000子程序名返回值类型异步公开备注1|2|3|4|5-6
230100玩家挑战系统
241100参数名类型备用可空初始值备注1|2|3|4|5|6
240000ID数值型
240000Json对象型
351100变量名类型备用备注10|8|4|41|2|3|4
350000Index数值型
350000玩家玩家类
350000被挑战玩家玩家类
350000属性玩家属性
Index = 玩家查找(ID)
!!如果(Index ==  - 1)
返回(0)
""如果结束()
 // 
玩家 = 数组玩家[Index]
 // 
!! // 如果(Json.id == 未定义)
 // 返回(0)
"" // 如果结束()


231000子程序名返回值类型异步公开备注1|2|3|4|5-6
230100角色创建
241100参数名类型备用可空初始值备注1|2|3|4|5|6
240000ID数值型
240000Json对象型
351100变量名类型备用备注6|6|4|41|2|3|4
350000玩家玩家类
 // 通过ID，查找角色
let Index = 玩家查找(ID)
服务端调试输出('角色创建' + Index + ' - ' + Json.name + ' - ' + Json.job)
!!如果(Index ==  - 1)
提示核心(ID, '非法操作')
返回(0)
""如果结束()
 // 
玩家 = 数组玩家[Index]
 // 
!!如果(Json.job == 未定义)
提示核心(ID, '请选择职业')
返回(0)
""如果结束()

!!如果(Json.name == 未定义)
提示核心(ID, '请输入角色名')
返回(0)
""如果结束()

let 名称长度 = 取文本长度(Json.name)
!!如果(名称长度 < 2)
提示核心(ID, '角色名过短')
返回(0)
""如果结束()

!!如果(名称长度 > 14)
提示核心(ID, '角色名过长')
返回(0)
""如果结束()
 // 查询角色名是否存在
let Sql = 数据配置.角色名查询
Sql = 文本替换( Sql , '#name' ,Json.name)
let ret = 数据库执行(Sql, 1)
 // 服务端调试输出('角色:' + ret)
let 账号对象 = 数据Json字符串到对象(ret)
!!如果(账号对象.errcode != 200)
提示核心(ID, '数据异常')
返回(0)
""如果结束()
 // 
!!如果(账号对象.data[0] != 未定义)
提示核心(ID, '角色名已存在')
返回(0)
""如果结束()
 // 写入数据角色信息
Sql = 数据配置.角色添加
 // 从玩家账号ID写入角色
Sql = 文本替换( Sql , '#accountid' ,玩家.accountid)
Sql = 文本替换( Sql , '#name' ,Json.name)
Sql = 文本替换( Sql , '#job' ,Json.job)
ret = 数据库执行取ID(Sql, 1, 1)
 // 服务端调试输出('角色:' + ret)
账号对象 = 数据Json字符串到对象(ret)
!!如果(账号对象.errcode != 200)
提示核心(ID, '数据异常')
返回(0)
""如果结束()
 // 
 // 提示核心(ID, '创建角色完毕')
 // 创建完毕后，进入角色系统
 // 玩家.accountid
 // 这里属于登录成功 传输玩家当前的角色库信息过去。
玩家获取角色(ID, 玩家.accountid, 1)

231000子程序名返回值类型异步公开备注1|2|3|4|5-6
230100玩家随机生成角色数值型返回角色ID
241100参数名类型备用可空初始值备注1|2|3|4|5|6
240000账号ID文本型
240000角色名文本型
Sql = 数据配置.角色添加
Sql = 文本替换( Sql , '#accountid' ,账号ID)
Sql = 文本替换( Sql , '#name' ,角色名)
ret = 数据库执行取ID(Sql, 1, 1)
let 账号对象 = 数据Json字符串到对象(ret)
!!如果(账号对象.errcode != 200)
返回(0)
""如果结束()
返回(账号对象.ID)

231000子程序名返回值类型异步公开备注15|10|4|4|41|2|3|4|5-6
230100数据_读取职业表
Sql = 数据配置.加载职业
ret = 数据库执行取ID(Sql, 1, 1)
let 职业对象 = 数据Json字符串到对象(ret)
!!如果(职业对象.errcode != 200)
返回(0)
""如果结束()
 // 初始化加载，要存到全局对象管理，用于下发给客户端的
系统配置.职业配置 = 职业对象.data


231000子程序名返回值类型异步公开备注1|2|3|4|5-6
230100玩家聊天处理
241100参数名类型备用可空初始值备注1|2|3|4|5|6
240000ID数值型
240000Json对象型
351100变量名类型备用备注6|6|4|41|2|3|4
350000Time数值型
350000玩家玩家类
 // 通过ID，查找角色
let Index = 玩家查找(ID)
服务端调试输出('角色发消息' + Index + ' - ' + Json.type + ' - ' + Json.str)
!!如果(Index ==  - 1)
提示核心(ID, '非法操作')
返回(0)
""如果结束()
 // 
玩家 = 数组玩家[Index]
 // 是否设定玩家消息间隔 暂时测试不设置间隔国家与世界。统一都可以发送到世界。
let Tjson = {}
Tjson.Hex = 3000
Tjson.name = 玩家.属性.名称
Tjson.type = Json.type
Tjson.str = Json.str
 // 
!!数组循环(数组玩家, i)
 // 注：与易语言不同的是 数组从0成员开始
!!如果(数组玩家[i].套接字 != 0)
服务端数据发送(数组玩家[i].套接字, Tjson)
""如果结束()
""数组循环结束()

231000子程序名返回值类型异步公开备注1|2|3|4|5-6
230100玩家获取PVP人物
241100参数名类型备用可空初始值备注1|2|3|4|5|6
240000ID数值型
240000Json对象型
351100变量名类型备用备注6|6|4|41|2|3|4
350000Tjson返回包
350000玩家玩家类
let Index = 玩家查找(ID)
!!如果(Index ==  - 1)
提示核心(ID, '非法操作')
返回(0)
""如果结束()
 // 
玩家 = 数组玩家[Index]
 // 
Tjson.Hex = 100000
Tjson.list = PVP获取人物(ID)
服务端数据发送(玩家.套接字, Tjson)

231000子程序名返回值类型异步公开备注1|2|3|4|5-6
230100玩家挑战PVP人物
241100参数名类型备用可空初始值备注1|2|3|4|5|6
240000ID数值型
240000Json对象型
351100变量名类型备用备注7|6|4|41|2|3|4
350000Tjson返回包
350000玩家玩家类
350000PVP对象玩家类
let Index = 玩家查找(ID)
!!如果(Index ==  - 1)
提示核心(ID, '非法操作')
返回(0)
""如果结束()
 // 
玩家 = 数组玩家[Index]
 // 设定要pk的玩家
服务端调试输出('玩家挑战PVP-' + Json.id)
let nindex = 玩家查找角色id(Json.id)
!!如果(nindex ==  - 1)
提示核心(ID, '请对真实玩家发起PVP战争~', )
返回(0)
""如果结束()
PVP对象 = 数组玩家[nindex]
 // 设定玩家战斗
玩家.开始挂机 = 假
玩家.攻击目标 = 0
 // 
玩家.PVP对象 = PVP对象
 // 
Tjson.Hex = 100001
服务端数据发送(玩家.套接字, Tjson)
 // 发送刷出对战玩家的信息
let nobj = {}
 // 
nobj.生命值 = PVP对象.属性.生命大
nobj.id = PVP对象.属性.id
nobj.名称 = PVP对象.属性.名称

服务端调试输出('刷出PVP应战玩家:' + nobj.名称)
 // 推送客户端刷怪
Json = 数据Json初始化()
Json.hex = 6008
Json.index = 5 // 永远刷在右边吧~
Json.info = nobj
服务端数据发送(玩家.套接字, Json)



231000子程序名返回值类型异步公开备注1|2|3|4|5-6
230100玩家挑战PVP开始
241100参数名类型备用可空初始值备注1|2|3|4|5|6
240000ID数值型
240000Json对象型
351100变量名类型备用备注6|6|4|41|2|3|4
350000玩家玩家类
let Index = 玩家查找(ID)
!!如果(Index ==  - 1)
提示核心(ID, '非法操作')
返回(0)
""如果结束()
 // 
玩家 = 数组玩家[Index]
!!如果(玩家.属性.生命小 <= 0)
提示核心(ID, '请阁下复活后再来吧~', )
返回(0)
""如果结束()


 // 设定要pk的玩家
服务端调试输出('玩家挑战PVP-开始战斗')
 // 设定玩家PVP战斗系统开始
玩家.开始PVP = 真



231000子程序名返回值类型异步公开备注1|2|3|4|5-6
230100玩家挑战PVP停止
241100参数名类型备用可空初始值备注1|2|3|4|5|6
240000ID数值型
240000Json对象型
351100变量名类型备用备注6|6|4|41|2|3|4
350000玩家玩家类
let Index = 玩家查找(ID)
!!如果(Index ==  - 1)
提示核心(ID, '非法操作')
返回(0)
""如果结束()
 // 
玩家 = 数组玩家[Index]
 // 设定要pk的玩家
服务端调试输出('玩家挑战PVP-停止战斗')
 // 设定玩家PVP战斗系统开始
玩家.开始PVP = 假
玩家.PVP对象 = 0
玩家.PVP挂接 = 0

231000子程序名返回值类型异步公开备注1|2|3|4|5-6
230100玩家点击摊位
241100参数名类型备用可空初始值备注1|2|3|4|5|6
240000ID数值型
240000Json对象型
351100变量名类型备用备注8|10|4|41|2|3|4
350000玩家玩家类
350000摊位ID数值型
350000摊位摊位配置表
350000JsonEx摊位返回包
350000摊位玩家玩家类
let Index = 玩家查找(ID)
!!如果(Index ==  - 1)
提示核心(ID, '非法操作')
返回(0)
""如果结束()

提示核心(ID, '摊位功能暂未开放', ['好吧~'])


返回(0)

 // 
玩家 = 数组玩家[Index]
摊位ID = Json.id
!!如果(摊位ID == 未定义)
提示核心(ID, '摊位非法')
""如果结束()
 // 
摊位 = 摊位表查找(摊位ID)
服务端调试输出("===" + 摊位.id + "-" + 摊位.name + "-userid：" + 摊位.userid)
!!如果(摊位 == 0)
提示核心(ID, '摊位异常')
返回(0)
""如果结束()
 // 设置玩家点击的店铺
let 摊位索引 = 摊位表查找索引(摊位ID)
!!如果(摊位索引 ==  - 1)
提示核心(ID, '摊位异常')
返回(0)
""如果结束()
 // 设定当前玩家点击的摊位索引，方便操作。
玩家.置摊位索引(摊位索引)
服务端调试输出("设置摊位索引：" + 摊位索引)
 // 
JsonEx.Hex = 2012
!!如果(摊位.userid == 未定义 或 摊位.userid == 0 或 摊位.userid === '')
JsonEx.type = 1 // 1 摊位没有被占用 2 摊位已经被人占用. 3 摊位是自己的
 // 摊位1
提示核心(ID, '是否确认摆摊？（需要摊位费：' + 摊位.money1 + '）             ', ['太贵了', '我要摆摊'])
返回(0)
##否则
 // 添加当前摊位列表物品 通过当前玩家的物品位置来获取。
 // 这里判断下是否要检测摊位
!!如果(摊位.userid == 玩家.属性.id)
 // 弹出自己上架商品的页面
JsonEx.type = 3 // 1 摊位没有被占用 2 摊位已经被人占用 3 摊位是自己的
##否则
JsonEx.type = 2 // 1 摊位没有被占用 2 摊位已经被人占用  3 摊位是自己的
""如果结束()

let 摊位index = 玩家查找角色id(摊位.userid)

!!如果(摊位index ==  - 1)
提示核心(ID, '摊位占用未知错误')
返回(0)
""如果结束()
 // 传递摊位数据
摊位玩家 = 数组玩家[摊位index]
 // 
JsonEx.List = 摊位玩家.物品获取摊位()
 // 
服务端数据发送(ID, JsonEx)

""如果结束()

231000子程序名返回值类型异步公开备注1|2|3|4|5-6
230100玩家开始摆摊玩家想要购买摊位，进入摆摊状态
241100参数名类型备用可空初始值备注1|2|3|4|5|6
240000ID数值型
240000Json开始摆摊包
351100变量名类型备用备注8|10|4|41|2|3|4
350000JsonEx开始摆摊包
350000玩家玩家类
350000摊位索引数值型
350000摊位摊位配置表
350000属性玩家属性
 // 通知客户端，展开摆摊系统
let Index = 玩家查找(ID)
!!如果(Index ==  - 1)
提示核心(ID, '非法操作')
返回(0)
""如果结束()
 // 
玩家 = 数组玩家[Index]
 // 检测金钱是否能够买摊位
属性 = 玩家.取属性()
 // 
摊位 = 摊位取属性(玩家.摊位索引)
 // 
服务端调试输出("玩家金币：" + 属性.金币 + " 摊位费：" + 摊位.money1 + "摊位索引：" + 玩家.摊位索引)

!!如果(摊位.userid == 未定义 或 摊位.userid == 0 或 摊位.userid === '')
!!如果( ~~ 属性.金币 <~~ 摊位.money1)
提示核心(ID, '阁下的钱不足够支付摆摊费。')
返回(0)
""如果结束()
##否则
提示核心(ID, '摊位已经被人先占用了。')
返回(0)
""如果结束()
 // 
提示核心(ID, '你可以上架商品了')
 // 进入了摆摊状态 
玩家.置摆摊状态(真)
 // 
属性.金币 =~~ 属性.金币 -~~ 摊位.money1
 // 动态ID，下线，摊位就没了，或者保留一段时间，超时就没了。
摊位.userid = 属性.id
摊位.name = 属性.名称
 // 通知客户端 这里要注意，实际是要通知当前区所有玩家
JsonEx.Hex = 2013
JsonEx.name = 属性.名称
JsonEx.index = 玩家.摊位索引
服务端数据发送(ID, JsonEx)

服务端调试输出("玩家摆摊成功 剩余金币：" + 属性.金币 + " 摊位费：" + 摊位.money1 + "摊位索引：" + 玩家.摊位索引)

231000子程序名返回值类型异步公开备注1|2|3|4|5-6
230100玩家离开摆摊
241100参数名类型备用可空初始值备注1|2|3|4|5|6
240000ID数值型
240000Json询问离开包
351100变量名类型备用备注8|10|4|41|2|3|4
350000JsonEx开始摆摊包
350000玩家玩家类
350000摊位索引数值型
350000摊位摊位配置表
350000属性玩家属性



let Index = 玩家查找(ID)
!!如果(Index ==  - 1)
提示核心(ID, '非法操作')
返回(0)
""如果结束()
玩家 = 数组玩家[Index]

服务端调试输出("确定离开摊位吗？" + 玩家.摆摊状态)
!!如果(玩家.摆摊状态 == 真)
提示核心(ID, '确定要收摊离开市场吗？\n摊位费已扣除不予退还。\n\n', ['离开市场'\\'继续摆摊'])
##否则
提示核心(ID, '不继续逛逛了吗？\n', ['离开市场'\\'我再逛逛'])
""如果结束()
 // 服务端数据发送(ID, JsonEx)

231000子程序名返回值类型异步公开备注1|2|3|4|5-6
230100玩家移动玩家移动，如果需要同屏，那么这里需要广播给其他玩家，因为放置游戏，所以不需要考虑太多。
241100参数名类型备用可空初始值备注1|2|3|4|5|6
240000ID数值型
240000Json移动包
351100变量名类型备用备注6|6|4|321|2|3|4
350000玩组数组型当前获取同地图的其他网络玩家数组
350000玩家玩家类
let Index = 玩家查找(ID)
!!如果(Index ==  - 1)
提示核心(ID, '非法操作')
返回(0)
""如果结束()
 // 
玩家 = 数组玩家[Index]
 // 玩家移动，广播给同屏其他玩家
玩组 = 玩家获取同地图(ID, 玩家.属性.地图ID)
 // 广播
let JsonEx = 申明自定义(移动同步包)
JsonEx.hex = 4000
JsonEx.type = 1 // 同步移动
JsonEx.index = Index
JsonEx.dx = Json.dx
JsonEx.dy = Json.dy
 // 
!!数组循环(玩组, i)
 // 注：与易语言不同的是 数组从0成员开始
 // 将自己的移动包推送给其他人
服务端数据发送(玩组[i].套接字, JsonEx)

""数组循环结束()
 // 内存记录自己的坐标，不建议记录到数据库。离线时候记录到数据库即可。这里不严谨，但实际无所谓了。毕竟放置游戏。不需要那么严谨，这些小问题不影响
 // 正常其实是客户端在坐标移动里面每一个坐标都通讯。但放置就不需要那么复杂了。
玩家.属性.x = Json.dx
玩家.属性.y = Json.dy




